Еще раз взглянем на файл с тестом:

./../files/__tests__/index.test.js

---------------------- CODE start ---------------------------

import reverse from '../src/index.js';

test('reverse', () => {
  const str = 'hello';
  expect(reverse(str)).toEqual('olleh');
  expect(reverse('')).toEqual('');
})

---------------------- CODE end ---------------------------


Для тестов Jest предоставляет две глобальные функции: test и expect.
Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.

Функция test нужна для описания конкретного теста и его проверок. Самих тестовых
функций может быть любое количество. Первым параметром эта функция принимает произвольную
строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во
время запуска тестов для упрощения отладки.

npx jest
 PASS  __tests__/index.test.js
  ✓ reverse (11ms) # название теста


Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание
на то, что этот код не выполняется сразу. Функция test добавляет его внутрь Jest,
который уже решает, как и когда запускать тесты. Это позволяет проводить различные
оптимизации, например, выполнять тесты параллельно.

--------

Самое необычное в этом коде — проверки. Jest использует "матчеры" (matchers).
Это утверждения (asserts), имеющие особую структуру, напоминающую обращение к объекту. Общий
принцип работы матчеров такой:

  - Вызывается функция expect(), куда передаётся актуальное (фактическое) значение.
  - На результате, возвращаемом функцией expect(), вызывается подходящий матчер, например,
    toEqual.



Код с матчерами похож на обычные предложения на английском языке. Это сделано специально,
чтобы их могли читать даже не программисты:

// Ожидается, что результат выражения reverse('hello') равен 'olleh'

expect(reverse('hello')).toEqual('olleh');


Одна из приятнейших особенностей Jest — то, как он выводит сообщения о проваленных проверках.
Попробуйте внести ошибку в исходную функцию и запустите тесты заново:

См. файл: ./../files/src/index.js

Расскоментируем код с ошибкой и запустим тест:

1. Заменили код на неправильный
2. Выполняем команду
    > npm run test

--------

Получем что-то на подобии такого вывода:

✕ reverse (4 ms)

  ● reverse

    expect(received).toEqual(expected) // deep equality

    Expected: "olleh"
    Received: "hello"

      2 |
      3 | test('reverse', () => {
    > 4 |     expect(reverse('hello')).toEqual('olleh');
        |                              ^
      5 |     expect(reverse('')).toEqual('');
      6 | });
      7 |

      at Object.<anonymous> (__tests__/index.test.js:4:30)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.307 s, estimated 1 s


В этом выводе показаны не только ожидаемое и фактическое значение, но и исходный код файла
с тестами с указанием на конкретную проверку. Это невероятно полезная фишка, которая
значительно ускоряет анализ результатов тестирования и помогает в отладке.

